// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var StringOrd = /* module */[/* compare */$$String.compare];

var StringMap = $$Map.Make(StringOrd);

var env = Curry._3(StringMap[/* add */3], "_tracing_type$", /* TDefined */Block.__(4, [
        "_tracing_type",
        /* TSum */Block.__(2, [
            /* TLit */Block.__(1, [/* LString */["jaeger"]]),
            /* TSum */Block.__(2, [
                /* TLit */Block.__(1, [/* LString */["opentracing"]]),
                /* TLit */Block.__(1, [/* LString */["none"]])
              ])
          ])
      ]), Curry._3(StringMap[/* add */3], "_path$", /* TDefined */Block.__(4, [
            "_path",
            /* TIO */0
          ]), Curry._3(StringMap[/* add */3], "_password$", /* TDefined */Block.__(4, [
                "_password",
                /* TPassword */1
              ]), Curry._3(StringMap[/* add */3], "_enabled$", /* TDefined */Block.__(4, [
                    "_enabled",
                    /* TLit */Block.__(1, [/* LBool */1])
                  ]), Curry._3(StringMap[/* add */3], "_url$", /* TDefined */Block.__(4, [
                        "_url",
                        /* TRegexp */Block.__(3, ["#\\w+://.+#i"])
                      ]), StringMap[/* empty */0])))));

console.log(env);

var e1 = /* EObject */Block.__(0, [Curry._3(StringMap[/* add */3], "postgres_url", /* EString */Block.__(1, ["tcp://postgress@postgress:postgress/"]), StringMap[/* empty */0])]);

var r1 = "{postgres_url = _url of regexp}";

var e2 = /* EObject */Block.__(0, [Curry._3(StringMap[/* add */3], "mysql_slave_password", /* EString */Block.__(1, ["$!L!K@L!@KJ$LKH@!$"]), StringMap[/* empty */0])]);

var r2 = "{mysql_slave_password = _password of password}";

var e3 = /* EObject */Block.__(0, [Curry._3(StringMap[/* add */3], "is_enabled", /* ETrue */0, StringMap[/* empty */0])]);

var r3 = "{is_enabled = _enabled of bool}";

var e4 = /* EObject */Block.__(0, [Curry._3(StringMap[/* add */3], "distributed_tracing_type", /* EString */Block.__(1, ["opentracing"]), StringMap[/* empty */0])]);

var r4 = "{distributed_tracing_type = _tracing_type of sum [jaeger of string, sum [opentracing of string, none of string]]}";

var e5 = /* EObject */Block.__(0, [Curry._3(StringMap[/* add */3], "icon_path", /* EString */Block.__(1, ["./path/to/local/file.png"]), StringMap[/* empty */0])]);

var r5 = "{icon_path = _path of io}";

function infereRecord(env, key, e) {
  return Curry._3(StringMap[/* fold */10], (function (k, v, agg) {
                if (agg !== undefined) {
                  return agg;
                } else if (new RegExp(k).test(key)) {
                  return v;
                } else {
                  return undefined;
                }
              }), env, undefined);
}

function typeInference(env, e) {
  if (typeof e === "number") {
    return /* TLit */Block.__(1, [/* LBool */1]);
  } else if (e.tag) {
    return /* TLit */Block.__(1, [/* LString */[e[0]]]);
  } else {
    return /* TRecord */Block.__(0, [Curry._2(StringMap[/* mapi */23], (function (k, v) {
                      var x = infereRecord(env, k, v);
                      if (x !== undefined) {
                        return x;
                      } else {
                        console.log("Cannot find type for key=", k);
                        return typeInference(env, e);
                      }
                    }), e[0])]);
  }
}

function $caret(a, b) {
  return Curry._2(Format.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* End_of_format */0
                        ])
                    ]),
                  "%s%s"
                ]), a, b);
}

function showType(t) {
  if (typeof t === "number") {
    if (t === 0) {
      return "io";
    } else {
      return "password";
    }
  } else {
    switch (t.tag | 0) {
      case 0 : 
          return Curry._1(Format.sprintf(/* Format */[
                          /* Char_literal */Block.__(12, [
                              /* "{" */123,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "}" */125,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "{%s}"
                        ]), Curry._3(StringMap[/* fold */10], (function (k, v, agg) {
                            return $caret(agg, $caret(k, $caret(" = ", showType(v))));
                          }), t[0], ""));
      case 1 : 
          var l = t[0];
          if (typeof l === "number") {
            if (l !== 0) {
              return "bool";
            } else {
              return "int";
            }
          } else {
            return $caret(l[0], " of string");
          }
      case 2 : 
          return $caret("sum [", $caret(showType(t[0]), $caret(", ", $caret(showType(t[1]), "]"))));
      case 3 : 
          return "regexp";
      case 4 : 
          return $caret(t[0], $caret(" of ", showType(t[1])));
      
    }
  }
}

function test_it(p) {
  var r = p[1];
  var e = p[0];
  console.log("run expression of", e);
  console.log("given   :", showType(typeInference(env, e)));
  console.log("expected:", r);
  if (showType(typeInference(env, e)) === r) {
    return 0;
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Typed.re",
            188,
            4
          ]
        ];
  }
}

console.log("typed");

List.map(test_it, /* :: */[
      /* tuple */[
        e1,
        r1
      ],
      /* :: */[
        /* tuple */[
          e2,
          r2
        ],
        /* :: */[
          /* tuple */[
            e3,
            r3
          ],
          /* :: */[
            /* tuple */[
              e4,
              r4
            ],
            /* :: */[
              /* tuple */[
                e5,
                r5
              ],
              /* [] */0
            ]
          ]
        ]
      ]
    ]);

exports.StringOrd = StringOrd;
exports.StringMap = StringMap;
exports.env = env;
exports.e1 = e1;
exports.r1 = r1;
exports.e2 = e2;
exports.r2 = r2;
exports.e3 = e3;
exports.r3 = r3;
exports.e4 = e4;
exports.r4 = r4;
exports.e5 = e5;
exports.r5 = r5;
exports.infereRecord = infereRecord;
exports.typeInference = typeInference;
exports.$caret = $caret;
exports.showType = showType;
exports.test_it = test_it;
/* StringMap Not a pure module */
